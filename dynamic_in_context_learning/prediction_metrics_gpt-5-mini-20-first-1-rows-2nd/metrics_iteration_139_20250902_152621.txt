PREDICTIVE METRICS - ITERATION 139
============================================================

Executive summary — immediate takeaways & top priorities (0–72h)
- What happened (short):
  - The recent 1‑record batch produced a false negative for Passenger 0179_03 (Age=3, all spend channels = 0). The model predicted Transported=False but actual=True. Root causes: model over‑relied on spend‑based signals (zero spends defaulted toward negative), lacked or under‑weighted cohort/family/cabin priors and age×all‑zero interactions, calibrator under‑estimated uncertainty for a small/rare Age_bucket × all_zero slice, and the decision system allowed n==1 auto‑decisions without special handling for “all_zero + very young” fragile records.
  - This is the complementary problem to the previously investigated top1_outlier false positive (0178_01): we are brittle at both extremes — extreme high spends generating overconfident positive logits, and all‑zero / rare‑age patterns generating overconfident negatives.

- Immediate priority (0–6h):
  - Stop auto‑decisions for n==1 records matching the new fragile slice: all_zero_flag AND Age ≤ AGE_INFANT_THRESHOLD (start 5). Add 0179_03 to the canary list and route to priority_audit.
  - Persist raw inputs, winsorized transforms, per‑feature logits, cohort/family prior snapshots and imputation provenance for canaries.
  - Expose per‑component variance and se in scorer logs so calibrator/uncertainty can be debugged rapidly.
  - Apply temporary gating: require GLM_fallback or ensemble corroboration to auto‑decide when all_zero_flag OR top1_outlier_flag OR high_total_spend_flag OR any per_channel_imputed_flag present in n==1 batches.

Concise answers to the six required questions (batch accuracy focus)
1) What specific patterns caused this error?
- Pattern: small‑N / rare slice consisting of very young passenger (Age=3) with all channel spends = 0. The model’s learned global correlation between low spend and lower transported probability dominated; the model lacked robust interaction features (Age × all_zero, family/cabin prior) and the calibrator did not inflate uncertainty for this rare slice → overconfident negative p_final in an n==1 batch.

2) How should decision rules be modified to prevent recurrence?
- Treat "age_under_threshold + all_zero" as fragile. For n==1 + fragile require corroboration (pooled_prior τ high, GLM_fallback agree, ensemble agreement, and low se_combined) else route to audit. Apply batch_frac_fragile hold for batches with multiple fragile records.

3) What new insights about transport patterns?
- Very young passengers with zero recorded spends form a distinct slice that often behaves differently from adults with zero spend. Family/cohort relationships and cabin/group priors are highly predictive here — absence of spend is not uniformly negative across age buckets.

4) How should confidence levels be recalibrated?
- Use heteroskedastic, slice‑aware calibration that increases uncertainty for:
  - Age_under5 × all_zero,
  - top1_outlier slices,
  - high_total_spend,
  - small‑N slices and n==1.
- Output p10/p50/p90 and sd; enforce higher se_floor for these fragile slices.

5) What adjustments are needed for batch consistency?
- Make cohort/group (Cabin / family name) a decision unit: conflicting cohort member predictions should hold the cohort. Add batch_frac_fragile gating and persistances of provenance across scorer/calibrator/gate.

6) How can metrics be improved to handle edge cases?
- Add explicit slice KPIs: age_under5_FN_rate, all_zero_FN_rate, n==1_fragile_auto_accept_rate and cohort_contradiction_rate. Expand pooled priors stratification to include Age_bucket × all_zero_flag and family/cabin prior.

Complete updated predictive metrics report — actionable components (optimized for batch prediction accuracy)

A. Feature engineering updates (v→v+1)
- Persist raw inputs (value + imputed_flag + method + source_date): RoomService, FoodCourt, ShoppingMall, Spa, VRDeck, Age, Cabin, Name, HomePlanet, CryoSleep, VIP.
- New / persisted flags and derived features:
  - sum_spend = sum of five channels (raw & log1p)
  - winsorized_spend[channel] and winsorized_sum_spend; is_winsorized_channel_flag
  - top1_channel, top1_spend, top1_share
  - top1_outlier_flag (as before)
  - all_zero_flag = (sum_spend == 0)
  - age_bucket: infant (0–1), toddler (1–4), early_child (5–11), teen (12–17), adult (18+)
  - infant_flag / child_under5_flag = Age ≤ AGE_INFANT_THRESHOLD (start 5)
  - family_name (last name parsing) and family_group_size (historic); cabin_group_size (historic)
  - cohort_transport_rate (historic) per family_name, per cabin_id, per cabin_group_size_bucket
  - age_x_allzero = interaction: age_bucket × all_zero_flag
  - num_high_spend_channels, multi_high_flag (as before)
  - outlier_score (Mahalanobis / LOF / isolation forest) relative to spend cluster centroids
  - per_channel_imputed_flags, missingness_count
  - sign_consistency and dominance_sign_consistency_score
- Transform changes:
  - Winsorize raw spends then log1p; use saturating transforms (tanh scaling) for sum_spend and top1_spend.
  - Buckets/ranks for top1_spend, sum_spend, age.

Recommended initial thresholds (sweepable):
- AGE_INFANT_THRESHOLD = 5 (start)
- CHANNEL_HIGH_THRESHOLD = 100
- MULTI_HIGH_THRESHOLD = 2
- SUM_SPEND_HIGH = 500
- TOP1_SPEND_OUTLIER_THRESHOLD = 1000 (as before)
- GLOBAL_SPEND_UPPER = 2000 (initial winsorization)

B. Pooled priors (expanded stratification + slice direction)
- Stratify priors by: Age_bucket × all_zero_flag, CryoSleep × all_zero_flag, sum_spend_bucket, top1_channel × top1_bucket, family_group_size_bucket, HomePlanet.
- For Age_under5 × all_zero slice set a specific N0_child to avoid global negative bias if that slice is small but systematic.
  - Example initial pseudo‑counts (sweepable): N0_child = 800; N0_top1_outlier = 1000; N0_multi_high = 400
- Blend: τ_slice = N_slice/(N_slice + N0_slice); μ_blend = τ_slice*μ_slice + (1−τ_slice)*μ_global.
- Persist pooled_prior_snapshot_id in outputs for auditability.

C. Per‑feature logit caps, winsorization & directionality handling
- Winsorize spends (GLOBAL_SPEND_UPPER) then compute transforms.
- Apply per‑feature and total logit clamps (including clamps on negative contributions), to avoid single feature dominating in either direction.
  - Example caps (start values): CAP_PER_FEATURE_LOGIT(spend)=1.5; CAP_SUM_SPEND_LOGIT=2.0; CAP_TOTAL_SPEND_LOGIT=2.0
- Special handling for all_zero_flag:
  - Allow explicit learnable positive or negative coefficient for age_x_allzero interaction, not implicit through missingness. That is: if historical evidence shows infant+all_zero → higher transported, model must be able to give a positive logit contribution up to a capped amount (e.g., 1.2).
- Down‑weight outlier spends (as before) but do not let winsorization/downsizing erase legitimate signals from age/cohort features.

D. Variance / SE model (add age/all_zero terms)
- Add variance components relevant to this case:
  - var_age_small = κ_age_small * indicator(age_bucket in {infant,toddler}) * (1 / sqrt(max(N_slice_age_bucket,1)))
  - var_all_zero = κ_all_zero * all_zero_flag
  - var_age_allzero_interaction = κ_age_allzero * age_x_allzero
  - var_top1_outlier, var_total_spend, var_multi_spend, var_outlier_detection (as before)
- Combine:
  - var_combined = var_base + var_age_small + var_all_zero + var_age_allzero_interaction + other var terms
  - se_combined = sqrt(max(var_combined, se_floor(context)^2))
- Starting κ (conservative; sweepable):
  - κ_age_small = 0.25; κ_all_zero = 0.20; κ_age_allzero = 0.30
  - keep κ_top1 = 0.28; κ_multi = 0.18; κ_total = 0.12; κ_novel = 0.14; κ_miss = 0.06
- SE floors:
  - n==1 & (all_zero + age_under5 OR top1_outlier OR high_total_spend): se_floor = 0.40–0.60 (start 0.45)
  - stable slices: se_floor = 0.06–0.10

E. Decision‑gating (pattern‑aware + batch/cohort aware)
- Fragile_flag_v3 = cryo_all_zero_flag OR top1_outlier_flag OR high_total_spend_flag OR multi_high_flag OR (all_zero_flag AND age_under5) OR high_novelty OR any per_channel_imputed_flag OR missingness_count ≥ 2 OR dominance_sign_consistency_score < threshold.
- Batch/cohort checks:
  - batch_frac_fragile = (#fragile_records_in_batch)/batch_size
  - If batch_frac_fragile ≥ BATCH_FRAGILE_THRESHOLD (start 0.05): hold auto‑decisions for batch; route to priority_audit/shadow.
  - If cohort_id or family_name present and inconsistent predictions within cohort: route whole cohort → priority_audit.
- n==1 gating for fragile_flag:
  - If fragile_flag and n_batch==1, require ALL:
      - pooled_prior_tau ≥ τ_high_slice AND N_slice ≥ N_min_slice
      - GLM_fallback_agrees (|p_model − p_glm| ≤ δ_slice)
      - ensemble_agreement ≥ A_high
      - se_combined ≤ SE_accept_slice AND (p90 − p10) ≤ QW_accept_slice
    Otherwise route → priority_audit.
- Example initial thresholds:
  - AGE_INFANT_THRESHOLD = 5
  - N_min_child = 120; N0_child = 800
  - Z_high_slice = 0.95; A_high = 0.995
  - SE_accept_child_slice = 0.10; se_floor_n1_child = 0.45
  - BATCH_FRAGILE_THRESHOLD = 0.05

F. Calibrator & GLM_fallback retrain plan (age/all_zero focused)
- Calibrator:
  - Heteroskedastic calibrator that outputs p10/p50/p90 & sd via quantile heads + variance net. Input features must include age_bucket, all_zero_flag, age_x_allzero, family_group_size, cohort_transport_rate, per_channel_imputed_flags, outlier_score and novelty_distance.
  - Loss: quantile pinball + ECE penalty + Brier; strongly upweight fragile slices:
    - age_under5×all_zero ×12, top1_outlier ×12, multi_high ×10, cryo_all_zero ×10.
- GLM_fallback:
  - ElasticNet logistic with explicit interactions: age_bucket × all_zero, age_bucket × family_group_size, family_group_transport_rate, cabin_group_size, top1_spend × Age_bucket. Force winsorized spends as inputs.
  - GLM_fallback_agrees if |p_model − p_glm| ≤ δ; initial δ=0.05 for fragile slices.
- Training:
  - Rolling window 18–36 months; targeted upsampling of age_under5×all_zero and top1_outlier in training and CV folds to ensure consistent estimates.
  - Shadow run: 14–28 days with gating active and canaries blocked from auto‑accept.
- Acceptance criteria:
  - age_under5_all_zero_FN_rate ↓ ≥ 40–60%
  - top1_outlier_FP_rate ↓ ≥ 40%
  - cohort contradiction rate ↓ ≥ 50%
  - global ECE not worse by >0.5% absolute

G. Monitoring, metrics & alerts (batch‑focused)
- Per‑slice KPIs (near‑real time):
  - age_under5_FN_rate (by family/cabin buckets), all_zero_FN_rate, top1_outlier_FP_rate, multi_high_FP_rate, n==1_auto_accept_rate, n==1_fragile_FN_rate
- Batch KPIs:
  - Batch_auto_decision_rate, Batch_frac_fragile, Batch_provenance_consistency_rate
- Alerts & pages:
  - Any canary auto‑accepted → immediate ML/Ops page.
  - age_under5_FN_rate increase > baseline + X% over 24h → page.
  - batch_frac_fragile ≥ threshold → automatically hold auto‑decisions & notify.
  - cohort contradiction autocase → page.
- Dashboards:
  - Per‑record provenance view for canaries and recent fragile auto‑decisions including winsorized vs raw, per_feature_logits, pooled_prior_snapshot.

H. CI unit tests & validation (cover age_under5_all_zero, top1_outlier, multi_high, cryo_all_zero)
- Unit tests:
  - Correct computation of all_zero_flag, age_bucket, age_x_allzero across scorer/calibrator/gate.
  - se_combined increases for age_under5_all_zero & high_total_spend & novelty_flag.
  - Calibrator widens p10/p90 for age_under5_all_zero records.
  - Pooled_prior blending respects large N0_child and prevents tiny N slices from dominating.
  - Per_feature & total logit caps enforced.
  - batch_frac_fragile ≥ threshold disables auto‑decisions.
  - cohort contradiction detection holds cohort.
  - Canaries (0179_03, 0178_01, 0174_01, 0172_01, 0171_01, 0170_01) must not be auto‑accepted during gating tests.
- Regression tests:
  - Global ECE, AUC, Brier degrade less than tolerance when gating enabled.
  - Integration tests validate end‑to‑end persistence of imputation provenance and per_feature_logit contributions.

I. Operational actions (0–72 hours) — precise timeline
1) Immediate (0–6h)
   - Deploy emergency gating patch: block auto‑decisions for any n==1 record with:
       - (all_zero_flag AND Age ≤ 5) OR
       - top1_spend ≥ 1000 OR
       - sum_spend ≥ 500 OR
       - num_high_spend_channels ≥ 2 OR
       - any per_channel_imputed_flag OR missingness_count ≥ 2
     Route these to priority_audit. Add 0179_03 and previous canaries (0178_01, 0174_01, 0172_01, 0171_01, 0170_01) to canary list.
   - Persist provenance fields: raw per‑channel spends, winsorized_spends, per‑feature logit contributions, pooled_prior_snapshot_id, cohort_id, family_group_size.
   - Expose variance/SE components in scoring output: var_age_small, var_all_zero, var_top1_outlier, var_combined, se_combined.
2) Short‑term (6–24h)
   - Implement new features (age_bucket, all_zero_flag, age_x_allzero, family_name aggregates) in scorer and retrain lightweight GLM_fallback on winsorized inputs.
   - Implement batch‑level hold if batch_frac_fragile ≥ 5% and cohort contradiction detection.
   - Instrument dashboards & alerts for age_under5_FN_rate and all_zero_FN_rate.
   - Start targeted label collection for recent age_under5_all_zero records (active labeling queue).
3) Mid‑term (24–72h)
   - Retrain calibrator & GLM_fallback with updated inputs and upweight schedule; run 14–28 day shadow‑run with gating active.
   - Publish pooled‑prior snapshots for age_x_allzero slices & top1/outlier slices.
   - Run CI/regression tests; tune winsorization cap & se_kappa values based on shadow diagnostics.

J. Per‑record provenance to log (required & extended)
- Raw per‑channel and imputation provenance: RoomService, FoodCourt, ShoppingMall, Spa, VRDeck (value + imputed_flag + imputation_method + source_date).
- Age & name: Age, Age_bucket, family_name, family_group_size, cabin_id, cabin_group_size
- Transforms & flags: winsorized_spend[channel], winsorized_sum_spend, log1p_transforms, is_winsorized_flag, all_zero_flag, age_x_allzero
- Aggregates & dominance: sum_spend, top1_channel, top1_spend, top1_share, top1_outlier_flag
- Novelty & anomaly: outlier_score, novelty_distance_norm, spend_cluster_id
- Model internals: per_feature_logit_contributions (map), pooled_prior_snapshot_id, μ_slice, τ_slice_blend
- Variances: var_age_small, var_all_zero, var_top1_outlier, var_multi_spend, var_combined, se_combined
- Decision meta: GLM_fallback_probs, GLM_fallback_agreement_flag, ensemble_probs, ensemble_agreement, p10/p50/p90, p_final_sd, quantile_width, gating_reasons, routing_decision, scorer_version, calibrator_version, provenance_hash

K. Initial hyperparameters (start values; sweepable)
- AGE_INFANT_THRESHOLD = 5
- CHANNEL_HIGH_THRESHOLD = 100
- MULTI_HIGH_THRESHOLD = 2
- SUM_SPEND_HIGH = 500
- TOP1_SPEND_OUTLIER_THRESHOLD = 1000
- GLOBAL_SPEND_UPPER = 2000
- CAP_PER_FEATURE_LOGIT (spend baseline) = 1.5
- CAP_SUM_SPEND_LOGIT = 2.0; CAP_TOTAL_SPEND_LOGIT = 2.0
- BATCH_FRAGILE_THRESHOLD = 0.05 (5%)
- N0_child = 800; N0_top1 = 1000; N0_multi_high = 400; N0_cryo_all_zero = 300
- N_min_child = 120; N_min_top1 = 200
- Z_high_slice = 0.95; A_high = 0.995
- SE_accept_child_slice = 0.10; se_floor_n1_child = 0.45
- κ_age_small = 0.25; κ_all_zero = 0.20; κ_age_allzero = 0.30; κ_top1 = 0.28; κ_multi = 0.18

L. CI canaries & expected behavior
- 0179_03 (Age=3, all_zero)
  - Expected: route -> priority_audit (unless pool priors/GLM/ensemble backing with very tight se_combined). Must not be auto‑accepted as False during gating tests.
- 0178_01 (RoomService extreme outlier)
  - Expected: route -> priority_audit (unless corroborated). Must not be auto‑accepted as True during gating tests.
- 0174_01 / 0172_01 / 0171_01 / 0170_01: previous canary behaviors retained.
- Unit tests assert inconsistent/cohort contradictory batches hold cohort and all canaries are audited.

Immediate one‑line corrective action
- Deploy emergency gating: route any n==1 record with (all_zero_flag AND Age ≤ 5) OR top1_spend ≥ 1000 OR sum_spend ≥ 500 OR num_high_spend_channels ≥ 2 OR any per_channel_imputed_flag OR missingness_count ≥ 2 to priority_audit; add 0179_03 and existing canaries to the canary list.

Concise gating pseudocode
- For each batch B:
  - batch_frac_fragile = count(r in B where fragile_flag)/|B|
  - if batch_frac_fragile ≥ BATCH_FRAGILE_THRESHOLD:
      route all r in B -> priority_audit; continue
  - for each record r in B:
      fragile_flag = cryo_all_zero_flag OR top1_outlier_flag OR (all_zero_flag AND Age ≤ AGE_INFANT_THRESHOLD) OR sum_spend ≥ SUM_SPEND_HIGH OR num_high_spend_channels ≥ MULTI_HIGH_THRESHOLD OR novelty_flag OR any per_channel_imputed_flag OR missingness_count ≥ 2 OR dominance_sign_consistency_score < 0.7
      if n_batch == 1 and fragile_flag:
         if (pooled_prior_tau ≥ Z_high_slice AND N_slice ≥ N_min_slice AND GLM_fallback_agrees AND ensemble_agreement ≥ A_high AND se_combined ≤ SE_accept_slice AND (p90 − p10) ≤ QW_accept_slice):
             allow auto_decision
         else:
             route r -> priority_audit
         continue
      if cohort_id or family_name present and exists conflicting sign predictions:
         route all cohort members -> priority_audit

Why this will reduce batch errors (short)
- We address both extremes:
  - Prevent overconfident positives from extreme spends by winsorization, per‑feature caps, outlier down‑weighting and pooled priors with high N0_top1.
  - Prevent overconfident negatives for rare small‑age all_zero records by explicit age_x_allzero features, cohort/family priors, variance inflation for small slices, and gating for n==1 fragile records.
- Calibrator, variance model and GLM fallback provide corroborating evidence before any n==1 auto decision. Canaries and slice KPIs surface regressions quickly.

Tradeoffs & operational notes
- Increased human review for gated records (prepare prioritized triage and labeling).
- Winsorization & stronger priors reduce extreme FPs but may blunt some true positives on the tails; mitigate by shadow runs and targeted labeling.
- Additional logging increases storage costs — keep retention policy tuned to TTR needs.

Next steps / offers
- Option A (0–3h, recommended): I will produce the exact emergency gating patch (code + unit tests) and CI canary tests including 0179_03 and 0178_01, plus a deploy checklist to implement stopgap protections now.
- Option B (24–72h): I will produce the full retrain recipe: calibrator training script, GLM_fallback spec with interactions (age_x_allzero, family priors), upweight schedule, CV fold design, hyperparameter sweep matrix, and shadow‑run dashboard spec.

Which do you want first? If you want the stopgap deployed immediately I will deliver the gating patch, unit tests, and deploy checklist now.

============================================================