PREDICTIVE METRICS - ITERATION 207
============================================================

Executive summary — immediate takeaways
- New fragile slice triggered a False Positive in a single‑record batch: Passenger 0243_01 (CryoSleep=True + explicit zero spends across all channels) was predicted Transported=True but actual=False (n==1).
- Root causes (short): the cryo_allzero signal was not preserved/flagged prior to imputation/transforms; the model + calibrator under‑estimated heteroskedastic uncertainty for this slice; small‑batch (n==1) auto_accept allowed an overconfident decision without a robust fallback/ensemble check.
- Immediate hotfix (deploy now): compute cryo_allzero (and other fragile) flags pre‑imputation; block auto_accept for any n==1 (and n ≤ 10) record with fragile flag unless GLM_fallback + ensemble concordance + p90−p10 + enforced SE floor checks pass; add 0243_01 to canary set and log reason codes; inflate calibrator variance for cryo_allzero and enforce a high SE floor for n==1.

Concise answers to the six operational questions (batch‑accuracy focus)
1) Which patterns caused the error?
- cryo_allzero (CryoSleep==True combined with an explicit zero spend vector or imputed zeros) — the model’s learned mapping for this slice is fragile or has shifted.
- Missingness/imputation leakage: NaNs→0 or imputation removed the “all‑zero / missing” signal.
- Small batch (n==1): auto_accept allowed an overconfident decision.
- Calibrator underestimated heteroskedastic uncertainty for cryo_allzero, producing narrow quantile ranges.

2) How should decision rules be modified?
- Compute fragility flags pre‑imputation.
- For fragile records in small batches (n ≤ 10; especially n==1) require ALL:
  - GLM_fallback agreement: |p_model − p_glm| ≤ δ_cryo (0.03),
  - Ensemble agreement ≥ A_high_cryo (0.995),
  - Quantile width (p90−p10) ≤ QW_accept_cryo (0.12),
  - se_combined ≥ se_floor_cryo (0.92).
  - Otherwise route record to priority_audit.
- If batch_frac_fragile ≥ 5% hold the whole batch for manual review.

3) New transport‑pattern insights?
- Cryo_allzero is a distinct behavioral slice: CryoSleep=True + zero spends is not equivalent to “no spend data” or normal zero spend — it often encodes cohort/context (e.g., in‑cryo passengers). The sign and strength of this signal are cohort‑conditioned (HomePlanet, Destination, cabin_deck), so treat it as a contextual slice, not a generic numeric pattern.
- Explicit zeros and NaNs mean different things and must be preserved as separate signals.

4) How should confidence be recalibrated?
- Retrain a heteroskedastic quantile calibrator conditioned on cryo_allzero and related fragility flags plus raw spend topology.
- Inflate variance for cryo_allzero via additive κ_cryo term; enforce se_floor for n==1 cryo_allzero records (hotfix: 0.92) until calibrator validated.

5) What adjustments are needed for batch consistency?
- Preserve raw spends and missingness bitmaps and compute fragility priors pre‑imputation.
- Gate auto_decisions for fragiles at record & batch level; require GLM_fallback and ensemble agreement for small‑n fragiles.
- Track batch_frac_fragile and use it to block/hold batches.

6) How can the metrics be improved for edge cases?
- Add slice KPIs (cryo_allzero FP/FN rates, n==1 fragile auto_accept rate).
- Persist canaries and per‑record provenance for triage/labeling.
- Oversample fragile slices for GLM_fallback and calibrator training; accept temporary increase in audits while model relearns.

Complete updated predictive metrics report (batch‑optimized, actionable)

A. What happened (concise)
- Failure: Passenger 0243_01 — CryoSleep=True + all channel spends 0.0 → Predicted Transported=True, Actual=False. Occurred in a single‑record batch (n==1).
- Core issues:
  - cryo_allzero slice not flagged pre‑imputation; imputation/transforms erased the distinguishing signal.
  - Model and calibrator produced overconfident prediction (low estimated SE).
  - Small‑n auto_accept allowed the decision to be taken without fallback/ensemble confirmation.

B. Immediate hotfix actions (0–3h)
1) Hotfix gating (deploy now)
   - Compute fragile_flag_v1 pre‑imputation. Minimum flags: cryo_allzero, super_dominant, multi_high_spend, per_channel_abs_outlier, missing_context (CryoSleep NaN, missing_cabin), all_spend_nan, imputed_zero_all.
   - If n_batch == 1 OR n_batch ≤ 10 AND fragile_flag_v1 is true:
     * Allow auto_decision ONLY if ALL pass:
       - GLM_fallback_agrees: |p_model − p_glm| ≤ δ_cryo (0.03 for cryo),
       - ensemble_agreement ≥ A_high_cryo (0.995 for cryo),
       - (p90 − p10) ≤ QW_accept_cryo (0.12),
       - se_combined ≥ se_floor_cryo (0.92).
     * Otherwise route to priority_audit.
   - If batch_frac_fragile ≥ 5% → hold entire batch.

2) Canary & CI
   - Add canaries: include 0237_01, 0239_01, 0241_01, 0243_01. Block auto_accept for these until hotfix validated.
   - Log reason codes for blocked/auto‑accepted canaries and page on any auto_accepted canary event.

3) Preserve provenance
   - Persist raw per_channel spends (NaNs preserved), per_channel_imputed_flags & imputation_method, missingness bitmap, and pre‑imputation flags.

4) Temporary calibrator tweak
   - Increase heteroskedastic SE for cryo_allzero in scoring (κ_cryo bump), enforce n==1 se_floor = 0.92 for cryo_allzero (hotfix).

5) Tighten per‑feature logit caps immediately
   - Lower CAP_PER_FEATURE_LOGIT to 0.60 and LOGIT_TOPK_SUM_CAP to 1.0 to avoid runaway logits from any single feature during hotfix.

C. Pre‑imputation detectors & flag definitions (compute before imputation)
- Preserve raw_spend vector and missingness bitmap.
- non_nan_spend_count
- zero_spend_vector_flag: all non‑NaN spends ≤ SPEND_ZERO_TOLERANCE AND non_nan_spend_count ≥ 1.
- cryo_allzero_flag: CryoSleep==True AND zero_spend_vector_flag.
- imputed_zero_all_flag: all channels were NaN but imputation set zeros (detect via per_channel_imputed_flags).
- all_spend_nan_flag: all channels are NaN.
- top1_channel, top1_value_raw, top1_share_raw.
- topk_sum_raw (sum of top K spends; K=3 by default).
- missing_context_flag: CryoSleep NaN OR Cabin NaN.
- fragility_score: composite score using zero_spend_vector, cryo_allzero_flag, missingness_count, top1_share_raw.

D. Feature engineering and preprocessing updates
- Preserve raw per_channel spends (NaNs) and feed pre‑imputation flags to both the main model and GLM_fallback.
- Add explicit features: cryo_allzero_flag, zero_spend_vector_flag, imputed_zero_all_flag, non_nan_spend_count, missing_context_flag, channel_entropy_raw.
- Interactions to add:
  - cryo_allzero_flag × Destination,
  - cryo_allzero_flag × cabin_deck,
  - missing_context_flag × HomePlanet / Destination.

E. Per‑feature logit caps & dampening (limit dominant feature influence)
- For each feature f compute raw logit contribution c_f; cap:
  - capped_c_f = sign(c_f) × min(|c_f|, CAP_PER_FEATURE_LOGIT).
- If sum(topk_positive_contribs) > LOGIT_TOPK_SUM_CAP then scale positives by β_high.
- Hotfix conservative values:
  - CAP_PER_FEATURE_LOGIT = 0.60
  - LOGIT_TOPK_SUM_CAP = 1.0
  - β_high = 0.45
- Exception: do not silently flip cryo boolean contributions — if capping would flip a cryo flag sign, route to priority_audit instead of masking.

F. Variance / heteroskedastic SE model (inflate uncertainty for fragiles)
- var_combined = var_base +
    κ_cryo*I(cryo_allzero_flag) +
    κ_super_dom*I(super_dominant_flag) +
    κ_multi_high*I(multi_high_spend_flag) +
    κ_impute*imputed_count +
    κ_missing*missingness_count
- Recommended κ starting values (hotfix; tunable):
  - κ_cryo = 1.90
  - κ_super_dom = 1.80
  - κ_multi_high = 1.80
  - κ_impute = 0.30
  - κ_missing = 0.60
- se_combined = sqrt(max(var_combined, se_floor(context)^2))
- SE floor (hotfix):
  - n==1 & cryo_allzero_flag → se_floor = 0.92
  - n==1 & super_dominant_flag → se_floor = 0.90
  - n==1 & multi_high_spend_flag → se_floor = 0.90
  - n>1 but batch_frac_fragile > 5% → se_floor = 0.60

G. Decision‑gating (pattern‑aware + batch/cohort aware)
- fragile_flag_v2 = union(cryo_allzero, super_dominant, multi_high_spend, per_channel_abs_outlier, missing_context_flag, imputed_zero_all_flag, all_spend_nan_flag).
- batch_frac_fragile = count(fragile_flag_v2)/|B|.
- Routing:
  - If batch_frac_fragile ≥ 0.05 → route entire batch to priority_audit.
  - For each fragile r in small batches (n_batch ≤ 10):
    - Require: GLM_fallback_agrees (|p_model − p_glm| ≤ δ_slice), ensemble_agreement ≥ A_high, p90−p10 ≤ QW_accept_slice, se_combined ≥ se_floor. If any check fails → priority_audit.
  - For non‑fragile records allow normal auto_decisions.

H. Calibrator & GLM_fallback retrain plan
- Calibrator:
  - Heteroskedastic quantile calibrator (outputs p10/p50/p90) conditioned on fragile flags + raw spend topology (top1_share_raw, topk_sum_raw, total_spend_pctile, missingness_count, age_bucket, cabin_deck, Destination).
  - Loss: weighted pinball + median Brier + monotonicity regularizer; upweight fragile records 2–4×.
  - Shadow run 14–28 days; keep hotfix gating until validated.

- GLM_fallback:
  - ElasticNet logistic on winsorized log1p spends + fragile flags + missingness_bitmap + top1_share_raw + topk_sum_raw + age_bucket + cabin_deck + Destination + interactions.
  - Train with oversampling of cryo_allzero and other fragile slices (both labels) to capture conditional behavior.
  - Serve GLM_fallback for all batches; require GLM for small‑n fragiles to confirm/deny auto_decisions.

I. Mixture priors, cluster detection & slice conditioning
- Cluster on demographics + raw_spend_vector + missingness_signature + cabin_deck + Destination.
- Compute μ_cluster and N_cluster and blend with global μ_global using hierarchical shrinkage:
  - μ_blend = (N_cluster/(N_cluster + τ))*μ_cluster + (τ/(N_cluster + τ))*μ_global
- Gate reliability with N_min_slice = 60. For cryo_allzero clusters with N_cluster < N_min_slice treat as fragile and require audit/GLM agreement.

J. Monitoring, metrics & alerts (batch‑focused)
- New KPIs:
  - cryo_allzero_FP_rate and FN_rate by HomePlanet/Destination/cabin_deck.
  - n==1_auto_accept_rate; n==1_fragile_auto_accept_rate (target 0 during hotfix).
  - batch_frac_fragile, batch_hold_rate, caps_trigger_rate.
  - calibration coverage for fragile slices (observed coverage vs expected).
- Alerts:
  - Canary auto_accepted (including 0243_01) → immediate page.
  - cryo_allzero_FP_rate increase beyond threshold → page.
  - batch_frac_fragile ≥ threshold → hold + page.
  - caps_trigger_rate spike (>5% of records) → page.

K. CI unit tests & validation
- Unit tests:
  - Pre‑imputation flags computed before transforms; NaNs preserved.
  - cryo_allzero_flag triggers when CryoSleep==True AND zero_spend_vector_flag True.
  - imputed_zero_all_flag detection tests.
  - se_combined respects se_floor for n==1 cryo_allzero.
  - Gating logic prevents auto_accept for n==1 fragile unless safety checks pass.
- Regression tests:
  - Slice‑level FP/FN for cryo_allzero & multi_high_spend must not increase in staging.
- Synthetic stress tests:
  - Inject cryo_allzero positive & negative cases across HomePlanets and cabin_decks (include 0237_01, 0243_01) and verify gating + GLM behavior.

L. Operational actions & timeline (0–72h)
1) Immediate (0–3h)
   - Deploy hotfix gating for n==1 and n ≤ 10 fragiles; persist provenance; add canaries (include 0243_01); enforce temporary se_floors; tighten logit caps; log caps triggers.
2) Short (3–24h)
   - Implement pre‑imputation detectors + baseline GLM_fallback; compute batch_frac_fragile dashboards; start label audit of historical cryo_allzero cases including canaries.
   - Shadow run GLM and heteroskedastic calibrator.
3) Mid (24–72h)
   - Retrain heteroskedastic calibrator & GLM_fallback using audited fragile labels; integrate cluster priors; run extended shadow run (14–28 days) before relaxing hotfix gating.
4) Longer term
   - Retrain main model with explicit cryo_allzero interactions and robust spend topology features; integrate hierarchical cluster priors; monthly recalibration.

M. Per‑record provenance to log (minimum)
- Raw per_channel spends (NaNs preserved), per_channel_imputed_flags & imputation_method.
- cryo_allzero_flag, imputed_zero_all_flag, super_dominant_flag, multi_high_spend_flag, missing_context_flag, top1_channel, top1_value_raw, top1_share_raw, topk_sum_raw.
- sum_raw_spend, total_spend_pctile, non_nan_spend_count, channel_entropy_raw.
- Model internals: per_feature_logit_contributions (raw & capped), caps_triggered, dampening_reason, pooled_prior_snapshot_id, μ_slice, τ_slice_blend.
- Variance: var_components, var_combined, se_combined.
- Decision meta: GLM_fallback_probs, GLM_fallback_agreement_flag, ensemble_probs, p10/p50/p90, gating_reasons, routing_decision, scorer_version.
- Canary event logs when a canary is routed/auto_accepted.

N. Initial hyperparameters (start values; sweepable)
- SPEND_ZERO_TOLERANCE = 1e‑6
- CHANNEL_SPEND_PCTILE_HIGH = 0.95
- TOPK_SUM_PERC = 0.995
- SE floor n==1 cryo_allzero = 0.92
- κ_cryo = 1.90; κ_super_dom = 1.80; κ_multi_high = 1.80; κ_topk_high = 0.85
- CAP_PER_FEATURE_LOGIT = 0.60; LOGIT_TOPK_SUM_CAP = 1.0; β_high = 0.45
- BATCH_FRAGILE_THRESHOLD = 0.05
- N_min_slice = 60
- δ_cryo = 0.03; A_high_cryo = 0.995; QW_accept_cryo = 0.12

O. Gating pseudocode (pattern‑aware, batch focused)
- For each batch B:
  - compute batch_frac_fragile = count(r in B where fragile_flag_v2)/|B|.
  - If batch_frac_fragile ≥ BATCH_FRAGILE_THRESHOLD: route all r -> priority_audit; continue.
  - For each r in B:
    - compute pre‑imputation flags with NaNs preserved.
    - set fragile_flag_v2 = union(...)
    - If fragile_flag_v2 AND n_batch ≤ 10:
      - If GLM_fallback_agrees & ensemble_agreement ≥ A_high & se_combined ≥ se_floor & (p90 − p10) ≤ QW_accept:
        - allow auto_decision
      - Else:
        - route r -> priority_audit
    - Else:
      - allow normal auto_decisions (with usual calibrator checks)

P. Specific diagnosis — short chain of failure for 0243_01
- Raw: Passenger 0243_01: CryoSleep=True; RoomService/FoodCourt/ShoppingMall/Spa/VRDeck = 0.0; HomePlanet=Earth; Cabin=G/37/S; Destination=TRAPPIST-1e.
- Failure chain:
  1) Pre‑imputation detection absent: cryo_allzero signal was not computed/preserved; if any NaNs were present earlier they may have been imputed to zeros and imputation flags lost.
  2) Model scoring used transformed features (zeros may map differently than intended) and likely relied on cohort priors or other features that produced a positive transport logit.
  3) Calibrator under‑estimated variance for the cryo_allzero slice producing tight p intervals (p90−p10 small).
  4) n==1 auto_accept logic allowed auto_decision without GLM or ensemble confirmation → FP accepted into production.
- Mitigation: pre‑flag cryo_allzero before transforms; inflate heteroskedastic variance for this slice; require GLM_fallback + ensemble concordance + quantile width checks for n==1 fragiles.

Q. How these changes reduce batch errors (short)
- Pre‑imputation detection preserves the cryo_allzero signal and forces gating.
- Per‑feature logit caps and topk dampening prevent single features (or transformations of zeros) from producing runaway logits.
- Heteroskedastic calibrator widens uncertainty where appropriate.
- GLM_fallback + ensemble gating act as an interpretable safety net for small‑n fragiles.

R. Tradeoffs & operational notes
- Expect short‑term increase in audits & latency for fragile small batches; that is an acceptable tradeoff to avoid production FPs/FNs in fragile slices.
- Slight compute increase (GLM_fallback, extra calibrator checks); keep gating limited to small‑n fragiles to minimize total cost.
- Global metrics may appear to shift temporarily as fragile slices are reweighted and audited labels are corrected.

S. Runnable checklist (concrete)
- Do NOT auto‑accept any n==1 record where fragile_flag_v2 is present UNLESS GLM+ensemble+calibrator safety checks pass.
- Add 0243_01 and other fragile canaries to CI; block auto_accept until validated.
- Persist raw spend vectors (NaNs preserved), per_channel_imputed_flags, and pre‑imputation flags in logs.
- Enforce temporary se_floors (cryo 0.92) and GLM_fallback gating.
- Tighten CAP_PER_FEATURE_LOGIT to 0.60 and LOGIT_TOPK_SUM_CAP to 1.0 for hotfix.
- Start labeling/auditing historical cryo_allzero cases.

T. Next steps — prioritized deliverables
1) Immediate: Hotfix gating + Canary CI (PR + unit tests that block auto_accept of fragile canaries). Minimal code change; immediate risk mitigation.
2) Short: Implement GLM_fallback training pipeline; persist raw spends and pre‑imputation flags; compute batch_frac_fragile dashboards; start label audit of historical fragile cases including 0243_01.
3) Mid: Retrain heteroskedastic calibrator & GLM_fallback using audited fragile labels; integrate cluster priors; run shadow run (14–28 days) before relaxing hotfix gating.
4) Long: Retrain main model with explicit cryo_allzero and multi_high_spend interactions; integrate hierarchical priors; monthly recalibration.

Targets and acceptance criteria
- With hotfix gating active: n==1 fragile auto_accepted rate → 0.
- After retrain & shadow: reduce cryo_allzero FP_rate and multi_high_spend FP_rate by ≥50% OR reduce auto_accept_rate for fragiles to <2% of total auto_decisions while holding acceptable global ECE/AUC.
- Canaries (incl. 0243_01) must never be auto_accepted without passing gating checks during hotfix.

Why this addresses 0243_01
- 0243_01 will be detected pre‑imputation as cryo_allzero; hotfix gating prevents auto_accept for n==1 fragiles unless GLM & ensemble agree and uncertainty measures pass. Tightening per‑feature caps prevents transformed zeros or a single prior from producing an overconfident positive logit. Calibrator variance inflation and SE floors prevent overly narrow intervals for this slice.

Would you like me to:
- Produce the hotfix PR skeleton (code + unit tests + canary asserts) now? (recommended first), or
- Produce the GLM_fallback training notebook + baseline metrics, or
- Produce the heteroskedastic calibrator spec & hyperparameter sweep plan?

Recommendation: hotfix gating + Canary CI first. If you confirm, I will produce the hotfix PR pseudocode + unit tests + canary asserts immediately.

============================================================