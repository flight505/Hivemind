PREDICTIVE METRICS - ITERATION 200
============================================================

Executive summary — immediate takeaways
- New single‑record failure (0233_01): multi_high_spend / spa_dominant false positive. Passenger has CryoSleep=False but very large spends (Spa=1438, ShoppingMall=256, RoomService=56) → model predicted Transported=True but actual=False. This is a different brittle mode from cryo_allzero (0232_01) but shares the same systemic root cause: fragile slices (both zero‑spend and extreme‑spend patterns) were not detected/handled, leading to overconfident, cohort‑mismatched decisions in n==1 batches.
- Root cause (short): fragile record patterns (cryo_allzero, super_dominant/multi_high_spend, per_channel outliers) were not flagged pre‑processing; imputation and raw feature transformations erased or amplified semantics; per‑feature contributions ran away for high spends; calibrator under‑estimated uncertainty for these slices; small‑n auto_accept rules allowed an overconfident incorrect prediction.
- Immediate hotfix (recommended): add pre‑imputation fragile detectors (including multi_high_spend/spa_dominant), enforce stricter gating for n==1 (and small n ≤ 10) fragile records — require GLM_fallback agreement, ensemble concordance, quantile width & SE floors, or route to priority_audit. Add 0233_01 (and earlier canaries 0225_01, 0231_01, 0232_01) to CI.

Concise answers to the six operational questions (batch‑accuracy focus)
1) Which patterns caused the error?
- multi_high_spend / super_dominant (one channel or a small set of channels dominates spend; Spa dominates here) produced extreme positive logit contributions. These patterns are high‑variance: label association varies by cohort (destination, cabin, age, VIP) and are brittle when N_slice is small. Also cryo_allzero pattern (previous failures) is a fragile opposite mode where missingness/zeros map inconsistently to labels across cohorts.

2) How should decision rules be modified?
- Compute fragile flags pre‑imputation and treat them as gating inputs.
- For fragile_flag AND n_batch ≤ 10 (strong for n==1):
  - Require GLM_fallback_agrees (|p_model − p_glm| ≤ δ_slice),
  - ensemble_agreement ≥ A_high,
  - p90 − p10 ≤ QW_accept_slice AND se_combined ≥ slice_se_floor,
  - Else route to priority_audit.
- If batch_frac_fragile ≥ 5% → hold entire batch for manual review.

3) New transport‑pattern insights?
- High spend does not universally indicate Transported; cohort/context matters. Multi_high_spend/spa_dominant records are heterogenous: in some clusters high spend correlates with transported=True, in others it correlates with False. Missingness vs explicit zero spend also has cohort‑dependent semantics.

4) How should confidence be recalibrated?
- Use a heteroskedastic quantile calibrator conditioned on fragile flags and continuous indicators (top1_share_raw, missingness_count, total_spend_pctile, age_bucket, cabin_deck, Destination). Inflate uncertainty for fragile slices (κ_cryo, κ_super_dom, κ_multi_high) and enforce SE floors for small‑n.

5) What adjustments are needed for batch consistency?
- Preserve raw per_channel spends (NaNs preserved), compute fragility pre‑imputation, gate auto_decisions for fragiles at record and batch level, require GLM_fallback for small batches/fragiles, track batch_frac_fragile and throttles.

6) How can the metrics be improved for edge cases?
- Persist provenance, add canaries for brittle examples (includes 0233_01), add GLM_fallback + heteroskedastic calibrator conditioned on audited fragile labels, track slice KPIs, accept temporary audit increases to fix brittle FP/FN modes.

Complete updated predictive metrics report (batch‑optimized, actionable)

A. What happened (concise)
- Failure: 0233_01 — CryoSleep=False; high spend vector (Spa dominant) → model predicted True but actual False.
- Root causes:
  - Fragile slices (multi_high_spend / super_dominant and cryo_allzero) not detected prior to imputation/transform; NaN semantics and extreme values were not treated as fragile.
  - Per‑feature contributions (logit terms) could run away for extreme channels, producing overconfident predictions.
  - Calibrator under‑inflated uncertainty on these slices; no GLM_fallback gating for n==1.

B. Immediate hotfix actions (0–3h)
1) Hotfix gating (deploy now)
   - Compute fragile_flag_v1 pre‑imputation (cryo_allzero, super_dominant, multi_high_spend, per_channel_abs_outlier, any_missing_channel, all_spend_nan).
   - If n_batch == 1 OR n_batch ≤ 10 AND fragile_flag_v1 is true:
     * Only allow auto_decision if ALL pass:
       - GLM_fallback_agrees: |p_model − p_glm| ≤ δ_slice (δ_cryo = 0.03, δ_super_dom = 0.03, δ_multi_high = 0.04),
       - ensemble_agreement ≥ A_high (0.995),
       - (p90 − p10) ≤ QW_accept_slice (0.12),
       - se_combined ≥ slice_se_floor enforced (see F).
     * Otherwise route to priority_audit.
   - If batch_frac_fragile ≥ 5% → hold whole batch and page ops.

2) Per‑feature caps & dampening (fast deploy)
   - Apply per_feature_logit_cap at scoring time (see E). For immediate patch, enforce CAP_PER_FEATURE_LOGIT = 0.9 and topk dampening (LOGIT_TOPK_SUM_CAP = 1.4, scale β_high = 0.6) to prevent runaway positive contributions like Spa=1438 causing misclassification.
   - Log caps_triggered and dampening_reason.

3) Persist raw provenance & add canaries
   - Log raw per_channel spends (NaNs preserved), per_channel_imputed_flags & method, fragile flags.
   - Add canaries: 0225_01, 0231_01, 0232_01, 0233_01 to CI; block auto_accept for canaries while hotfix is active.

4) Enforce SE floors for small‑n fragiles
   - n==1 & cryo_allzero or super_dominant or multi_high_spend → se_combined ≥ 0.85
   - n==1 & other fragile → se_combined ≥ 0.75

C. Pre‑imputation detectors & flag definitions (compute before any imputation)
- Preserve raw_spend vector and missingness bitmap.
- non_nan_spend_count
- zero_spend_vector_flag: all non‑NaN spend channels ≤ SPEND_ZERO_TOLERANCE AND non_nan_spend_count ≥ 1.
- cryo_allzero_flag: CryoSleep==True AND zero_spend_vector_flag.
- top1_channel, top1_value_raw, top1_share_raw = top1_value_raw/(sum_raw_spend+tiny_eps).
- super_dominant_flag: top1_share_raw ≥ 0.80 AND top1_value_raw ≥ channel_95pctile.
- multi_high_spend_flag: count(channel ≥ channel_pctile_threshold (95th)) ≥ 2.
- per_channel_abs_outlier_flag: robust zscore(channel) ≥ Z_THRESHOLD (e.g., 6).
- any_missing_channel_flag, all_spend_nan_flag, channel_entropy_raw.
- fragility_score: monotonic composite of top1_share_raw, non_nan_spend_count (low → more fragile), missingness_count, cryo_allzero_flag, super_dominant_flag, multi_high_spend_flag.

D. Feature engineering and preprocessing updates
- Preserve raw per_channel spends (NaNs preserved).
- winsorized_log1p(channel_spend) per channel (winsorize per channel 99.5th).
- channel_percentile_raw, top1_value_raw, top1_share_raw, topk_sum, top1/top2_ratio_raw, channel_entropy_raw.
- any_missing_channel_flag, zero_spend_vector_flag, all_spend_nan_flag, non_nan_spend_count.
- Interactions to add:
  - cryo_allzero_flag × Age_bucket × cabin_deck × Destination.
  - multi_high_spend_flag × top1_channel × Destination × cabin_deck.
  - top1_share_raw × Age_bucket.
- Persist pre‑imputation flags to model inputs and for downstream gating/logging.

E. Per‑feature logit caps & dampening (prevent runaway positives/negatives)
- Compute per_feature_logit_contrib = w_f × value_f (use raw or preprocessed value consistent with model).
- capped_contrib = sign(contrib) × min(|contrib|, CAP_PER_FEATURE_LOGIT).
- If sum(topk_positive_contribs) > LOGIT_TOPK_SUM_CAP then scale positives by β_high.
- If sum(topk_negative_contribs) < −LOGIT_TOPK_SUM_NEG_CAP then scale negatives by β_zero.
- Do NOT bluntly zero out cryo signal — require GLM_fallback before overriding cryo contributions.
- Start values (tunable):
  - CAP_PER_FEATURE_LOGIT = 0.9
  - LOGIT_TOPK_SUM_CAP = 1.4
  - LOGIT_TOPK_SUM_NEG_CAP = 1.6
  - β_zero = 0.6
  - β_high = 0.60
- Log caps_triggered & dampening_reasons per record.

F. Variance / heteroskedastic SE model (inflate uncertainty for fragiles)
- var_combined = var_base +
    κ_top1_high*I(top1_pctile ≥ 0.95) +
    κ_super_dom*I(super_dominant_flag) +
    κ_cryo*I(cryo_allzero_flag) +
    κ_infant*I(infant_allzero_flag) +
    κ_impute*imputed_count +
    κ_missing*missingness_count +
    κ_multi_high*I(multi_high_spend_flag)
- Recommended κ starting values:
  - κ_top1_high = 0.65
  - κ_super_dom = 1.40
  - κ_cryo = 1.60
  - κ_infant = 0.60
  - κ_impute = 0.25
  - κ_missing = 0.30
  - κ_multi_high = 1.10
- se_combined = sqrt(max(var_combined, se_floor(context)^2))
- SE floors:
  - n==1 & cryo_allzero_flag → se_floor = 0.85
  - n==1 & super_dominant_flag → se_floor = 0.85
  - n==1 & multi_high_spend_flag → se_floor = 0.85
  - n==1 & other fragile_flag → se_floor = 0.75
  - n>1 but batch_frac_fragile > 5% → se_floor = 0.55

G. Decision‑gating (pattern‑aware + batch/cohort aware)
- fragile_flag_v2 = union(cryo_allzero, super_dominant, infant_allzero, single_channel_dominant, multi_high_spend, per_channel_abs_outlier, any_missing_channel, all_spend_nan_flag, imputed_count ≥ 1).
- batch_frac_fragile = count(fragile_flag_v2)/|B|.
- If batch_frac_fragile ≥ BATCH_FRAGILE_THRESHOLD (0.05) → route entire batch to priority_audit.
- n==1 fragile gating:
  - Allow auto decision ONLY if ALL:
    * pooled_prior_tau ≥ τ_high_slice AND N_slice ≥ N_min_slice,
    * GLM_fallback_agrees (|p_model − p_glm| ≤ δ_slice),
    * ensemble_agreement ≥ A_high,
    * se_combined ≤ SE_accept_slice AND (p90 − p10) ≤ QW_accept_slice.
  - For cryo_allzero, super_dominant, multi_high_spend require stricter tolerances:
    * δ_cryo = 0.03; δ_super_dom = 0.03; δ_multi_high = 0.04; A_high = 0.995.
  - If GLM disagrees or quantile width too wide → priority_audit.

H. Calibrator & GLM_fallback retrain plan
- Calibrator:
  - Heteroskedastic quantile calibrator producing p10/p50/p90 conditioned on fragile flags and continuous features (top1_share_raw, total_spend_pctile, missingness_count, age_bucket, cabin_deck, Destination).
  - Loss: weighted pinball + Brier for median + monotonicity regularizer.
  - Shadow run 14–28 days; keep hotfix gating until validated.

- GLM_fallback:
  - ElasticNet logistic on winsorized log1p spends + fragile flags + missingness_bitmap + top1_share_raw + age_bucket + cabin_deck + Destination + interactions.
  - Serve GLM_fallback for all batches; require GLM for small‑n fragiles auto_decisions.
  - Reweight fragile slices in training to ensure representativeness (oversample cryo_allzero, multi_high_spend, super_dominant cases, include both labels). Include historical examples (0225_01, 0231_01, 0232_01, 0233_01) in validation splits.

I. Mixture priors, cluster detection & slice conditioning
- Cluster on demographics + raw_spend_vector + missingness_signature + cabin_deck + Destination.
- Compute μ_cluster and N_cluster and blend with global μ_global using hierarchical shrinkage.
- Use cluster N to gate reliability (N_min_slice = 60). For cryo_allzero or multi_high_spend clusters with N_cluster < N_min_slice treat as fragile regardless and require audit/GLM agreement.

J. Monitoring, metrics & alerts (batch‑focused)
- New KPIs:
  - cryo_allzero_FN_rate and FP_rate by cohort (Destination, cabin_deck, age_bucket).
  - super_dominant_FP_rate / FN_rate by channel (Spa_FP_rate etc).
  - multi_high_spend_FP_rate / FN_rate by top1/topk bins.
  - top1_share calibration bins ([0.8–0.9, 0.9–0.95, >0.95]).
  - n==1_auto_accept_rate; n==1_fragile_auto_accept_rate.
  - batch_frac_fragile, batch_hold_rate, caps_trigger_rate.
- Alerts:
  - Canary auto_accepted (0225_01, 0231_01, 0232_01, 0233_01) → immediate page.
  - Fragile auto_accept_rate above target → page.
  - batch_frac_fragile ≥ threshold → hold + page.

K. CI unit tests & validation
- Unit tests (must run pre‑deploy):
  - Pre‑imputation flags computed before transforms; NaNs preserved.
  - cryo_allzero_flag triggers when CryoSleep==True AND zero_spend_vector_flag True.
  - super_dominant_flag & multi_high_spend_flag detection tests (use synthetic both labels).
  - se_combined respects se_floor for n==1 cryo_allzero, super_dominant, multi_high_spend.
  - Gating logic prevents auto_accept for n==1 fragile unless safety checks pass.
- Regression tests:
  - Slice‑level FP/FN for cryo_allzero, super_dominant, multi_high_spend must not increase post‑change.
- Synthetic stress tests:
  - Inject cryo_allzero & multi_high_spend positive/negative cases (include 0225_01, 0231_01, 0232_01, 0233_01) across Destinations and cabin_decks and verify gating and GLM behavior.

L. Operational actions & timeline (0–72h)
1) Immediate (0–3h)
   - Deploy hotfix gating for n==1 and n ≤ 10 fragiles. Persist provenance. Enforce se_floor and CI tests with canaries.

2) Short (3–24h)
   - Implement pre‑imputation detectors + baseline GLM_fallback; compute batch_frac_fragile; start dashboards for fragile slice KPIs; begin label audit of historical fragile cases including 0225_01, 0231_01, 0232_01, 0233_01.
   - Shadow run GLM and heteroskedastic calibrator.

3) Mid (24–72h)
   - Retrain heteroskedastic calibrator and GLM_fallback conditioned on audited fragile labels; deploy cluster priors; run extended shadow run (14–28 days) before relaxing hotfix gating.

4) Longer term
   - Retrain main model with explicit interactions for cryo_allzero and multi_high_spend slices, integrate cluster priors, and automate monthly percentile recompute and hyperparameter sweeps.

M. Per‑record provenance to log (minimum)
- Raw per_channel spends (NaNs preserved), per_channel_imputed_flags & imputation_method.
- cryo_allzero_flag, multi_high_spend_flag, top1_channel, top1_value_raw, top1_share_raw, super_dominant_flag.
- sum_raw_spend, total_spend_pctile, non_nan_spend_count, channel_entropy_raw.
- Model internals: per_feature_logit_contributions (raw & capped), caps_triggered, dampening_reason, pooled_prior_snapshot_id, μ_slice, τ_slice_blend.
- Variance: var_components, var_combined, se_combined.
- Decision meta: GLM_fallback_probs, GLM_fallback_agreement_flag, ensemble_probs, p10/p50/p90, gating_reasons, routing_decision, scorer_version.
- Push canary event logs when a canary is routed or auto_accepted.

N. Initial hyperparameters (start values; sweepable)
- SPEND_ZERO_TOLERANCE = 1e‑6
- TOTAL_SPEND_OUTLIER_PERC = 0.995
- CHANNEL_SPEND_PCTILE_HIGH = 0.95
- SE floor n==1 cryo_allzero = 0.85
- SE floor n==1 super_dominant = 0.85
- SE floor n==1 multi_high_spend = 0.85
- SE floor n==1 fragile (other) = 0.75
- κ_super_dom = 1.40; κ_cryo = 1.60; κ_multi_high = 1.10; κ_top1_high = 0.65
- β_zero = 0.6; β_high = 0.60
- CAP_PER_FEATURE_LOGIT = 0.9; LOGIT_TOPK_SUM_CAP = 1.4
- BATCH_FRAGILE_THRESHOLD = 0.05
- N_min_slice = 60; τ_high_slice = 0.95
- δ_slice (GLM tolerance) = 0.05; δ_cryo = 0.03; δ_super_dom = 0.03; δ_multi_high = 0.04
- A_high (ensemble agreement) = 0.995
- QW_accept_slice (quantile width) = 0.12

O. Gating pseudocode (pattern‑aware, batch focused)
- For each batch B:
  - compute batch_frac_fragile = count(r in B where fragile_flag_v2)/|B|.
  - If batch_frac_fragile ≥ BATCH_FRAGILE_THRESHOLD: route all r -> priority_audit; continue.
  - For each r in B:
    - compute pre‑imputation flags (cryo_allzero_flag, super_dominant_flag, multi_high_spend_flag, etc.) with NaNs preserved.
    - set fragile_flag_v2 = union(...).
    - If fragile_flag_v2 AND n_batch ≤ 10:
      - If GLM_fallback_agrees & ensemble_agreement ≥ A_high & se_combined ≤ SE_accept AND (p90 − p10) ≤ QW_accept:
        - allow auto_decision
      - Else:
        - route r -> priority_audit
    - Else If n_batch == 1 and fragile_flag_v2:
      - If pooled_prior_tau ≥ τ_high_slice AND N_slice ≥ N_min_slice AND GLM_fallback_agrees AND ensemble_agreement ≥ A_high AND se_combined ≤ SE_accept_slice AND (p90 − p10) ≤ QW_accept_slice:
        - allow auto_decision
      - Else:
        - route r -> priority_audit

P. Specific diagnoses — short chains of failure
- Passenger 0233_01 (spa_dominant / multi_high_spend false positive)
  - Raw: CryoSleep=False; RoomService=56.0; ShoppingMall=256.0; Spa=1438.0; FoodCourt=0.0 → top1_channel=Spa, top1_share_raw high; multi_high_spend_flag true.
  - Failure chain:
    1) Fragile flags not computed pre‑scoring, or their gating not enforced.
    2) Per_feature_logit_contribution from Spa and ShoppingMall dominated the logit (uncapped), pushing p_model high.
    3) Calibrator did not inflate quantile width for multi_high_spend slices; se_combined was low.
    4) n==1 auto_accept allowed this overconfident FP without GLM check → FP accepted.

- Passenger 0232_01 & 0225_01 (cryo_allzero contradictory labels)
  - Reinforce that identical raw patterns can map to different labels depending on cohort/context; must treat as fragile slice and condition on cluster.

Q. How these changes reduce batch errors (short)
- Pre‑imputation detection preserves missingness and flags extremes so model decisions incorporate fragility.
- Per‑feature caps/topk dampening prevent runaway contributors that cause super_dominant/multi_high_spend FPs.
- Heteroskedastic calibrator inflates uncertainty for fragiles so model reflects true uncertainty.
- GLM_fallback + ensemble gating provides interpretable safety checks for small‑n auto_decisions.
- Batch‑level gating prevents fragile‑heavy batches from being auto-accepted.

R. Tradeoffs & operational notes
- Increase in audits and human triage expected short term.
- Global metrics (AUC/ECE/Brier) may temporarily dip while brittle slice errors are patched — acceptable to protect production.
- Compute and latency increase from GLM_fallback & extra logging; gating limited to small‑n fragiles to contain cost.

S. Runnable checklist (concrete)
- Do NOT auto‑accept any n==1 record where cryo_allzero_flag OR super_dominant_flag OR multi_high_spend_flag OR per_channel_abs_outlier OR all_spend_nan_flag OR imputed_count ≥ 1 OR any_missing_channel_flag is present, UNLESS GLM+ensemble+calibrator safety checks pass.
- Add canaries 0225_01, 0231_01, 0232_01, 0233_01 to CI; block auto_accept unless safety checks are satisfied.
- Persist raw spend vectors (NaNs preserved) and pre‑imputation flags in logs.
- Deploy per_feature_logit_caps and topk dampening; log caps_triggered.

T. Next steps — prioritized deliverables
1) Immediate (highest priority): Hotfix gating + Canary CI (PR + unit tests blocking auto_accept of fragile canaries). Low code change; immediate risk mitigation.
2) Short: Implement GLM_fallback training pipeline, persist raw spends and pre‑imputation flags, compute batch_frac_fragile dashboards, start label audit of historical fragile cases. Shadow run GLM and calibrator for 14–28 days.
3) Mid: Retrain heteroskedastic calibrator and integrate cluster priors; apply per‑feature caps sequentially; relax hotfix only when slice KPIs stabilize.
4) Long: Retrain main model with explicit interactions for fragile slices; automate monthly percentile recomputes & hyperparameter sweeps.

Targets and acceptance criteria
- With hotfix gating active: n==1 fragile auto_accepted rate → 0.
- After retrain & shadow: reduce cryo_allzero FN_rate and super_dominant/multi_high_spend FP_rate by ≥50% OR reduce auto_accept_rate for fragiles to <2% of total auto_decisions while holding acceptable global ECE/AUC.

Why this addresses the 0233_01 failure specifically
- Detects multi_high_spend/spa_dominant pre‑scoring and treats it as fragile.
- Caps/dampens per‑feature positive contributions so Spa spending cannot alone force a high p_model.
- Requires GLM_fallback/ensemble agreement for n==1 small‑n fragiles so an interpretable model can veto runaway complex model outputs.
- Inflates calibrator uncertainty for multi_high_spend so p90−p10 widens and gating will route to audit if ambiguous.

Would you like me to:
- Produce the hotfix PR (code skeleton + unit tests + canary asserts) now? (recommended first), or
- Produce the GLM_fallback training notebook + baseline metrics, or
- Produce the heteroskedastic calibrator spec & hyperparameter sweep plan?

Recommendation: hotfix gating + canary CI first. If you confirm, I will produce the hotfix PR (pseudocode, unit tests, CI canary assertions) next.

============================================================