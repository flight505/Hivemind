PREDICTIVE METRICS - ITERATION 196
============================================================

Executive summary — immediate takeaways
- New failure: Passenger 0225_01 (CryoSleep=True, all spends = 0) was predicted Transported=False but actual=True — a classic cryo_allzero false negative in a single-record batch (n==1). The model treated the zero‑spend vector as a strong negative signal, overriding CryoSleep and other cohort/context signals.
- Root causes (consistent with prior brittle cases like super_dominant):
  - Fragile slice signal (cryo_allzero) not computed/used pre‑imputation or not used to gate uncertainty/decisions.
  - Missingness/zero vs NaN semantics destroyed during imputation → model conflated "no data" vs "true zeros".
  - Interactions (CryoSleep × zero_spend_vector × cohort) poorly represented in training; single-channel/zero patterns are heterogeneous across cohorts.
  - Calibrator not slice‑aware → under‑estimated uncertainty for cryo_allzero small‑n records and allowed overconfident low p.
  - Small‑n auto‑decision rules allowed n==1 auto_decision without GLM/ensemble gating → false negative accepted.
- Immediate mitigation (hotfix): treat cryo_allzero (and other fragiles) as fragile for n==1/small batches → require GLM_fallback + ensemble concordance + heteroskedastic SE floor OR route to priority_audit. Persist raw spends/NaNs and add cryo_allzero canary (0225_01) to CI.

Concise answers to the six operational questions (batch‑accuracy focus)
1) Which patterns caused the error?
- The cryo_allzero pattern: CryoSleep == True + all spending channels equal zero (or preserved NaN → imputed to 0) is a brittle slice with heterogeneous label distribution. The pipeline failed to treat it as fragile pre‑imputation and the model over‑relied on zero spend as negative predictive evidence.

2) How should decision rules be modified?
- Compute cryo_allzero and other fragile flags pre‑imputation. For n==1 or n ≤ 10 with any fragile_flag True: require GLM_fallback agreement (|p_model − p_glm| ≤ δ_slice), very high ensemble agreement, and heteroskedastic SE above a floor; otherwise route to priority_audit. If batch_frac_fragile ≥ 5% hold the batch.

3) New transport‑pattern insights?
- cryo_allzero is heterogeneous: in some demographic/cabin/destination clusters cryo_allzero correlates with transported=True; in others it correlates with False. Therefore top‑level features alone mislead — top‑level decisions must be conditioned by cohort/cluster.

4) How should confidence be recalibrated?
- Use heteroskedastic quantile calibration conditioned on fragile flags (cryo_allzero, super_dominant, any_missing_channel). Inflate variance for cryo_allzero and enforce SE floors for small‑n cases. Produce p10/p50/p90 and widen intervals for fragiles to stop overconfident auto_decisions.

5) What adjustments are needed for batch consistency?
- Persist raw spend vectors (NaNs preserved) and compute fragile flags BEFORE imputation. Gate auto‑decisions for fragiles at batch‑level. Block auto_accept for n==1 fragile unless stringent safety nets pass.

6) How can metrics be improved for edge cases like this one?
- Persist raw feature provenance; add cryo_allzero and super_dominant canaries (include 0225_01, 0223_01). Add GLM_fallback and heteroskedastic calibrator conditioned on audited fragile labels. Track slice KPIs and expect transient audit volume increase but large reduction in high‑impact brittle FPs/FNs.

Complete updated predictive metrics report (batch‑optimized, actionable)

A. What happened (short)
- Case 0225_01: CryoSleep=True, all spend channels = 0. Predicted Transported=False; actual True. Root causes: cryo_allzero slice not treated as fragile pre‑imputation, NaN/zero semantics lost, interaction effects (CryoSleep × zero_spend_vector × cohort) not modelled, calibrator under‑inflation of uncertainty, and n==1 auto‑decision policy allowed a brittle FN.

B. Immediate hotfix actions (0–3h)
1) Hotfix gating (deploy now)
   - If n_batch == 1 OR n_batch ≤ 10 AND fragile_flag in {cryo_allzero, super_dominant, multi_high_spend, infant_allzero, per_channel_abs_outlier, any_missing_channel, all_spend_nan}:
       * Route to priority_audit UNLESS ALL pass strict checks:
           - GLM_fallback_agrees: |p_model − p_glm| ≤ δ_slice (use δ_cryo tighter, e.g. 0.03)
           - ensemble_agreement ≥ A_high (start 0.995)
           - se_combined ≥ se_floor_fragile AND quantile width ≤ QW_accept
       * If any check fails → priority_audit.
   - If batch_frac_fragile ≥ 5% → hold entire batch.
2) Preserve raw provenance
   - Log raw per_channel spends (NaNs preserved), pre‑imputation flags, imputation methods. Add canaries: 0225_01 (cryo_allzero), 0223_01 (super_dominant), plus existing cryo canaries.
3) Enforce SE floor
   - For n==1 & cryo_allzero_flag → se_combined ≥ se_floor_cryo (start 0.85)
   - For n==1 & super_dominant_flag → se_combined ≥ se_floor_super_dom (0.85)
   - For n==1 & other fragiles → se_combined ≥ 0.75
4) Quick model-side safety
   - For cryo_allzero records do NOT apply aggressive positive/negative dampening blindly; instead route to GLM_fallback check. Avoid manual biasing until GLM_fallback is validated.
5) CI + unit tests
   - Block production deployment if any cryo_allzero canary (0225_01) or super_dominant canary (0223_01) is auto_accepted while hotfix enabled.

C. Pre‑imputation detectors & flag definitions (compute before any imputation)
- any_missing_channel_flag: True if any spend feature is NaN.
- all_spend_nan_flag: True if all spend channels are NaN.
- non_nan_spend_count.
- zero_spend_vector_flag: all non‑NaN spend channels ≤ ε AND non_nan_spend_count ≥ 1.
- cryo_allzero_flag: CryoSleep == True AND zero_spend_vector_flag == True.
- infant_allzero_flag: Age < 2 AND zero_spend_vector_flag == True.
- top1_channel, top1_value_raw, top1_share_raw = top1_value_raw/(sum_raw_spend+tiny_eps)
- super_dominant_flag: top1_share_raw ≥ 0.80 AND top1_value_raw ≥ channel_95pctile
- aggressive_super_dominant_flag: top1_share_raw ≥ 0.95
- multi_high_spend_flag: count(channels ≥ channel_pctile_threshold) ≥ 2 (95th pctile)
- per_channel_abs_outlier_flag: channel_value > channel_abs_max
- missingness_bitmap, channel_entropy_raw

D. Feature engineering and preprocessing updates
- Persist raw per_channel spends (NaNs preserved). Do NOT convert NaN → 0 silently.
- Generate:
  - winsorized_log1p(channel_spend) per channel (winsorize per channel 99.5th)
  - channel_percentile_raw
  - top1_value_raw, top1_share_raw, top1_pctile
  - topk_sum, top1/top2_ratio_raw, channel_entropy_raw
  - any_missing_channel_flag, zero_spend_vector_flag, all_spend_nan_flag, non_nan_spend_count
- Interactions to add:
  - cryo_allzero_flag × Age_bucket
  - cryo_allzero_flag × cabin_deck
  - cryo_allzero_flag × Destination
  - super_dominant_flag × cabin_deck, super_dominant_flag × Destination
  - cryo_allzero_flag × VIP

E. Per‑feature logit caps & dampening (prevent runaway positives/negatives while avoiding over‑damp of cryo signal)
- Winsorize per_channel spends at channel-specific MAX_PCTILE (99.5th). Preserve NaN/zero separation features.
- Compute per_channel_logit_contrib = w_c × feature. Apply:
  - capped_contrib = sign(contrib) × min(|contrib|, CAP_PER_CHANNEL_LOGIT)
  - If sum(topk_positive_contribs) > LOGIT_TOPK_SUM_CAP then scale positive contributions by β_high.
  - If sum(topk_negative_contribs) < −LOGIT_TOPK_SUM_NEG_CAP then scale negatives by β_zero to avoid runaway negative signal from all‑zero vectors.
- Important: do NOT apply automatic negative dampening to cryo_allzero without GLM_fallback/cluster check — cryo_allzero can legitimately predict positive.
- Start values (tuneable):
  - CAP_PER_CHANNEL_LOGIT = 0.9
  - LOGIT_TOPK_SUM_CAP = 1.4
  - LOGIT_TOPK_SUM_NEG_CAP = 1.6
  - β_zero = 0.6
  - β_high = 0.60
- Log caps_triggered & dampening_reasons per record.

F. Variance / heteroskedastic SE model (inflate uncertainty for fragiles)
- var_combined = var_base +
    κ_top1_high*I(top1_pctile ≥ 0.95) +
    κ_super_dom*I(super_dominant_flag) +
    κ_dom*I(single_channel_dominant_flag) +
    κ_cryo*I(cryo_allzero_flag) +
    κ_infant*I(infant_allzero_flag) +
    κ_impute*imputed_count +
    κ_missing*missingness_count +
    κ_multi_high*I(multi_high_spend_flag)
- Recommended start κ values:
  - κ_top1_high = 0.65
  - κ_super_dom = 1.40
  - κ_dom = 0.60
  - κ_cryo = 1.60 (raise from prior 1.20 — cryo_allzero produced high‑impact FN)
  - κ_infant = 0.60
  - κ_impute = 0.25
  - κ_missing = 0.30
  - κ_multi_high = 0.85
- se_combined = sqrt(max(var_combined, se_floor(context)^2))
- SE floors:
  - n==1 & cryo_allzero_flag → se_floor = 0.85
  - n==1 & super_dominant_flag → se_floor = 0.85
  - n==1 & other fragile_flag → se_floor = 0.75
  - n>1 but batch_frac_fragile > 5% → se_floor = 0.55

G. Decision‑gating (pattern‑aware + batch/cohort aware)
- fragile_flag_v2 = union(cryo_allzero, super_dominant, infant_allzero, single_channel_dominant, multi_high_spend, per_channel_abs_outlier, any_missing_channel, all_spend_nan_flag, imputed_count ≥ 1)
- batch_frac_fragile = count(fragile_flag_v2)/|B|
  - If batch_frac_fragile ≥ BATCH_FRAGILE_THRESHOLD (0.05) → route entire batch to priority_audit.
- n==1 fragile gating:
  - Allow auto decision ONLY if ALL hold:
    * pooled_prior_tau ≥ τ_high_slice AND N_slice ≥ N_min_slice,
    * GLM_fallback_agrees (|p_model − p_glm| ≤ δ_slice),
    * ensemble_agreement ≥ A_high,
    * se_combined ≤ SE_accept_slice AND (p90 − p10) ≤ QW_accept_slice.
  - For cryo_allzero and super_dominant require stricter tolerances:
    * δ_cryo = 0.03; δ_super_dom = 0.03; A_high = 0.995; se_floor enforced.
- For cryo_allzero records: require GLM_fallback where GLM explicitly includes cryo_allzero, zero_spend_vector_flag, and raw spends; if GLM disagrees, route to audit.

H. Calibrator & GLM_fallback retrain plan
- Calibrator:
  - Heteroskedastic quantile calibrator producing p10/p50/p90 conditioned on fragile flags and continuous features (top1_share_raw, total_spend_pctile, missingness_count, age_bucket, cabin_deck, Destination).
  - Loss: weighted pinball for quantiles + Brier for median + ECE regularizer.
  - Shadow run: 14–28 days; keep gating until validated.
- GLM_fallback:
  - ElasticNet logistic on winsorized log1p spends + fragile flags + missingness_bitmap + top1_share_raw + age_bucket + cabin_deck + Destination + interactions (especially cryo_allzero interactions).
  - Serve GLM_fallback for all batches; for small‑n fragile records make GLM output mandatory for auto‑decision.

I. Mixture priors, cluster detection & slice conditioning
- Cluster on demographics + raw_spend_vector + missingness_signature + cabin_deck + Destination.
- Compute μ_cluster and N_cluster and blend with global μ_global: posterior_mean = (N_cluster*μ_cluster + τ_global*μ_global)/(N_cluster + τ_global).
- Use cluster N to gate reliability (N_min_slice = 60). For cryo_allzero clusters with cluster N < N_min_slice treat as fragile regardless.

J. Monitoring, metrics & alerts (batch‑focused)
- New KPIs:
  - cryo_allzero_FN_rate / FP_rate (stratify by Destination, cabin_deck, age_bucket)
  - super_dominant_FP_rate / FN_rate
  - top1_share_binned calibration (e.g., [0.8–0.9, 0.9–0.95, >0.95])
  - n==1_auto_accept_rate; n==1_fragile_auto_accept_rate
  - batch_frac_fragile, batch_hold_rate
- Alerts:
  - Canary auto_accepted (0225_01 or 0223_01) → immediate page.
  - Fragile auto_accept_rate above target → page.
  - batch_frac_fragile ≥ threshold → hold + page.

K. CI unit tests & validation
- Unit tests:
  - Pre‑imputation flags computed before any transform and NaNs preserved.
  - cryo_allzero_flag triggers when CryoSleep == True AND zero_spend_vector_flag True.
  - se_combined respects se_floor for n==1 cryo_allzero.
  - Gating logic prevents auto_accept for cryo_allzero n==1 unless safety checks pass.
- Regression tests:
  - Slice‑level FP/FN for cryo_allzero and super_dominant must not increase post‑change.
- Synthetic stress tests:
  - Inject cryo_allzero positive/negative cases (include canary 0225_01) to validate gating and calibrator behavior.

L. Operational actions & timeline (0–72h)
1) Immediate (0–3h)
   - Deploy hotfix gating for n==1 and n ≤ 10 fragile records (include cryo_allzero and super_dominant). Persist provenance. Enforce se_floor and CI test with canaries.
2) Short (3–24h)
   - Implement pre‑imputation detectors + baseline GLM_fallback; compute batch_frac_fragile; instrument dashboards; start label audit of historical fragile cases (include 0225_01, 0223_01, 0222_02, etc.).
   - Shadow run GLM_fallback and calibrator predictions.
3) Mid (24–72h)
   - Retrain heteroskedastic calibrator and GLM_fallback conditioned on audited labels; deploy cluster priors; run extended shadow run (14–28 days) before relaxing hotfix gating.
4) Longer term
   - Monthly percentile recompute; automated hyperparameter sweeps for κs, se_floors, β params; continuous monitoring and retraining cadence.

M. Per‑record provenance to log (minimum)
- Raw per_channel spends (NaNs preserved), per_channel_imputed_flags & imputation_method.
- cryo_allzero_flag, top1_channel, top1_value_raw, top1_share_raw, super_dominant_flag.
- CryoSleep raw, Age raw + imputation flag.
- sum_raw_spend, total_spend_pctile, non_nan_spend_count, channel_entropy_raw.
- Model internals: per_feature_logit_contributions (raw & capped), caps_triggered, dampening_reason, pooled_prior_snapshot_id, μ_slice, τ_slice_blend.
- Variance: var_components, var_combined, se_combined.
- Decision meta: GLM_fallback_probs, GLM_fallback_agreement_flag, ensemble_probs, p10/p50/p90, gating_reasons, routing_decision, scorer_version.

N. Initial hyperparameters (start values; sweepable)
- SPEND_ZERO_TOLERANCE = 1e‑6
- TOTAL_SPEND_OUTLIER_PERC = 0.995
- CHANNEL_SPEND_PCTILE_HIGH = 0.95
- SE floor n==1 cryo_allzero = 0.85
- SE floor n==1 super_dominant = 0.85
- SE floor n==1 fragile (other) = 0.75
- κ_super_dom = 1.40; κ_cryo = 1.60; κ_multi_high = 0.85; κ_top1_high = 0.65
- β_zero = 0.6; β_high = 0.60
- CAP_PER_CHANNEL_LOGIT = 0.9; LOGIT_TOPK_SUM_CAP = 1.4
- BATCH_FRAGILE_THRESHOLD = 0.05
- N_min_slice = 60; τ_high_slice = 0.95
- δ_slice (GLM tolerance) = 0.05; δ_cryo = 0.03; δ_super_dom = 0.03
- A_high (ensemble agreement) = 0.995
- QW_accept_slice (quantile width) = 0.12

O. Gating pseudocode (pattern‑aware, batch focused; updated for cryo_allzero)
/* For each batch B:
   compute batch_frac_fragile = count(r in B where fragile_flag_v2)/|B|
   If batch_frac_fragile ≥ BATCH_FRAGILE_THRESHOLD: route all r -> priority_audit; continue
   For each r in B:
     compute pre‑imputation flags (cryo_allzero_flag, super_dominant_flag, etc.)
     set fragile_flag_v2 = union(...)
     If (cryo_allzero_flag OR super_dominant_flag OR multi_high_spend_flag) AND n_batch ≤ 10:
       If GLM + ensemble agreement & se_combined ≤ SE_accept AND quantile width small:
         allow auto_decision
       Else:
         route r -> priority_audit
     Else If n_batch == 1 and fragile_flag_v2:
       If pooled_prior_tau ≥ τ_high_slice AND N_slice ≥ N_min_slice AND GLM_fallback_agrees AND ensemble_agreement ≥ A_high AND se_combined ≤ SE_accept_slice AND (p90 − p10) ≤ QW_accept_slice:
         allow auto_decision
       Else:
         route r -> priority_audit
*/

P. Specific diagnosis — Passenger 0225_01 (chain of failure)
- Raw: CryoSleep = True; RoomService = 0; FoodCourt = 0; ShoppingMall = 0; Spa = 0; VRDeck = 0.
- Derived: zero_spend_vector_flag True; cryo_allzero_flag True.
- Failure chain:
  1) Pre‑imputation fragile flags either not computed or not used by gating: cryo_allzero not treated as fragile.
  2) Imputation pipeline converted NaNs/uniform zeros into features indistinguishable from “true zero” without preserving missingness bits; model treated zero spends as negative evidence.
  3) Model lacked interaction capacity for CryoSleep × zero_spend_vector × cohort; learned global negative weight on zero spend.
  4) Calibrator lacked heteroskedastic slice conditioning → under‑estimated uncertainty for cryo_allzero → narrow p interval.
  5) n==1 gating permitted auto decision without GLM_fallback/ensemble cross‑check → wrong negative accepted.
- Root causes: missing pre‑imputation fragile detection + imputation semantics loss + missing cryo interactions in model + calibrator/SE under‑inflation for cryo_allzero + absence of GLM_fallback gating.

Q. How these changes reduce batch errors (short)
- Pre‑imputation fragile detection ensures brittle patterns like cryo_allzero are flagged immediately.
- Preserving NaN vs zero separates “no data” from “true zero”; avoids misinterpretation.
- Adding cryo_allzero interactions and GLM_fallback prevents global negative spend‑bias from drowning cryo signal.
- Heteroskedastic variance and SE floors widen calibrated uncertainty for fragiles to avoid overconfident auto decisions.
- GLM_fallback + ensemble checks provide interpretable safety nets for small‑n decisions.
- Batch‑level gating prevents fragile‑heavy batches from being auto‑accepted.

R. Tradeoffs & operational notes
- Expect increased audit volume; plan human triage capacity for short term.
- Short‑term global metric shifts (AUC/ECE/Brier) possible; this is acceptable because it reduces high‑impact brittle errors.
- Compute/latency bump from GLM_fallback and extra logging; acceptable for small batches and high‑risk templates.
- Tuning κ_cryo and GLM tolerances is critical — too aggressive will route many benign records to audit; too lax will keep brittle FN/FP.

S. Runnable checklist (concrete)
- Do not auto‑accept any n==1 record where cryo_allzero_flag OR super_dominant_flag OR multi_high_spend_flag OR infant_allzero_flag OR per_channel_abs_outlier OR all_spend_nan_flag OR imputed_count ≥ 1 OR missingness flags present, unless GLM+ensemble+calibrator safety checks pass.
- Unit tests: canary cryo_allzero (0225_01) and super_dominant (0223_01) must be routed to priority_audit unless safety checks pass.
- Log per_feature_logit_contributions, caps_triggered, dampening_reasons, calibrator quantiles and GLM fallback outputs.

T. Next steps — recommended starting deliverables
1) Immediate: Push the hotfix gating package (pseudocode + unit tests + CI patch) so n==1 cryo_allzero and super_dominant cases are not auto_accepted. Persist provenance.
2) Simultaneous: Start historical label audit of cryo_allzero and super_dominant canaries (include 0225_01, 0223_01, 0222_02, 0222_01, ...). Instrument slice dashboards and collect audited labels.
3) Within 24–72h: Implement pre‑imputation detectors, baseline GLM_fallback, and retrain heteroskedastic calibrator using audited labels. Shadow run for 14–28 days, then relax hotfix gating only after validation.

Targets and acceptance criteria (post‑changes)
- n==1 fragile auto_accepted records → target 0 while gating active.
- After retrain & shadow run: reduce cryo_allzero slice FN_rate and super_dominant FP_rate by ≥50% OR reduce auto_accept_rate for fragiles to <2% of total auto_decisions while maintaining acceptable global ECE/AUC.
- Batch hold rate should remain <2–5% after threshold tuning.

Recommendation — what to start with now
- Highest priority: hotfix gating + canary CI (prevent further high‑impact brittle auto_decisions). This is low code change, immediate risk mitigation, and enables safe auditing.
- Next: GLM_fallback spec & baseline training pipeline (required for gating decisions).
- Then: heteroskedastic calibrator spec & shadow run.

I can prepare, prioritized:
1) Hotfix PR with unit tests (includes canaries 0225_01, 0223_01) — recommended first.
2) GLM_fallback training stub + validation metrics.
3) Heteroskedastic calibrator training spec and hyperparameter sweep plan.

Which should I produce first? Operational recommendation: hotfix gating + canary CI first. If you confirm, I will produce the hotfix PR (code skeleton + unit tests + canary assertions) next.

If you want, I can also:
- Produce the GLM_fallback training notebook + baseline metrics on historical data (including fragile slices).
- Produce the calibrator retrain schedule and sweep plan.

Summary note: This failure is symptomatic of two complementary brittleness classes — super_dominant runaways (single channel overwhelming the logit) and cryo_allzero mis‑interpretations (loss of NaN/zero semantics and missing interaction modeling). The unified mitigation is: (1) preserve raw provenance and compute fragile flags pre‑imputation; (2) gate small‑n fragile records with GLM_fallback + ensemble + heteroskedastic calibrator; (3) add per‑feature caps but avoid blunt application that removes legitimate cryo signal; (4) retrain models with cryo_allzero + cohort interactions and run a shadow validation. Deploy the hotfix gating now to stop more high‑impact brittle errors.

============================================================